import Foundation

/// An authorization string used to initialize the Braintree SDK
@objcMembers public class BTClientToken: NSObject, NSCoding, NSCopying {

    // TODO: resolve public access modifiers once rest of core is in Swift
    // MARK: - Public Properties

    /// The extracted authorization fingerprint
    public let authorizationFingerprint: String

    /// The extracted configURL
    public let configURL: URL

    /// The original string used to initialize this instance
    public let originalValue: String
    
    /// The URL for the Client API
    public let clientAPIURL: URL
    
    /// Client token version, possible values 1, 2 ,or 3
    public let version: Int
    
    // MARK: - Private Properties
    
    /// The client token as a BTJSON object
    private let json: BTJSON

    // MARK: - Initializers

    /// Initialize a client token with a client token string generated by a Braintree Server Library.
    /// - Parameter clientToken: A client token string generated by a Braintree Server Library
    @objc(initWithClientToken:error:)
    public init(clientToken: String) throws {
        // Client token must be decoded first because the other values are retrieved from it
        self.json = try Self.decodeClientToken(clientToken)
        
        guard let authorizationFingerprint = json["authorizationFingerprint"].asString(),
              !authorizationFingerprint.isEmpty else {
            throw BTClientTokenError.invalidJSONValue("authorizationFingerprint")
        }
        
        guard let configURL = json["configUrl"].asURL() else {
            throw BTClientTokenError.invalidJSONValue("configUrl")
        }
        
        guard let clientAPIURL = json["clientApiUrl"].asURL() else {
            throw BTClientTokenError.invalidJSONValue("clientApiUrl")
        }
        
        self.authorizationFingerprint = authorizationFingerprint
        self.configURL = configURL
        self.originalValue = clientToken
        self.clientAPIURL = clientAPIURL
        self.version = json["version"].asIntegerOrZero()
    }
    
    // MARK: - Internal helper functions

    private static func decodeClientToken(_ rawClientToken: String) throws -> BTJSON {
        let data: Data
        let isBase64: Bool

        if let base64Data = Data(base64Encoded: rawClientToken) {
            data = base64Data
            isBase64 = true
        } else if let utf8Data = rawClientToken.data(using: .utf8) {
            data = utf8Data
            isBase64 = false
        } else {
            throw BTClientTokenError.failedDecoding("Base64 or UTF8 encoding is required for Client Token.")
        }

        guard let clientTokenJSON = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw BTClientTokenError.invalidFormat("Invalid JSON. Expected to find an object at JSON root.")
        }

        guard let version = clientTokenJSON["version"] as? Int else {
            throw BTClientTokenError.invalidFormat("Invalid version number. Expected to find an integer for key \"version\".")
        }

        if version == 1 && isBase64 {
            throw BTClientTokenError.failedDecoding("UTF8 encoding is required for Client Token version 1.")
        } else if (version == 2 || version == 3) && !isBase64 {
            throw BTClientTokenError.failedDecoding("Base64 encoding is required for Client Token versions 2 & 3.")
        } else if version < 1 || version > 3 {
            throw BTClientTokenError.unsupportedVersion
        }

        return BTJSON(value: clientTokenJSON)
    }

    // MARK: - NSCoding conformance

    public func encode(with coder: NSCoder) {
        coder.encode(originalValue, forKey: "originalValue")
    }

    public required convenience init?(coder: NSCoder) {
        try? self.init(
            clientToken: coder.decodeObject(forKey: "originalValue") as? String ?? ""
        )
    }

    // MARK: - NSCopying conformance

    @objc(copyWithZone:)
    public func copy(with zone: NSZone? = nil) -> Any {
        do {
            return try BTClientToken(clientToken: self.originalValue)
        } catch {
            return error
        }
    }

    // MARK: - NSObject override

    public override func isEqual(_ object: Any?) -> Bool {
        guard object is BTClientToken,
              let otherToken = object as? BTClientToken else {
            return false
        }

        return self.json.asDictionary() == otherToken.json.asDictionary()
    }
}
